#include "Packages/com.unity.render-pipelines.high-definition/Runtime/PostProcessing/Shaders/ExposureCommon.hlsl"

#pragma enable_d3d11_debug_symbols

// TODO List to investigate
//  - Number of bins:
//      - Worth considering multiple histograms per lane in the thread. (i.e. sharedHisto[BINS][NUMB_HIST] )
//      - Worth checking the optimal group size.
//      - At the moment the dispatch is at half res, but the buffer sampled is full res,
//        causing fairly bad cache behaviour. Can we use the mip chain realistically without issues? [The one we have is blurred and might be incomplete?] 

// NOTE: fairly naive for now.

// TODO: Do mapping to 0.18 instead of 1 ? 


#pragma kernel KHistogramGen        GEN_PASS
#pragma kernel KHistogramReduce     REDUCE_PASS

#define _HistogramRangeScale     _HistogramExposureParams.x
#define _HistogramRangeBias      _HistogramExposureParams.y
#define _HistogramMinPercentage  _HistogramExposureParams.z
#define _HistogramMaxPercentage  _HistogramExposureParams.w


#define HISTOGRAM_BINS 128          // IMPORTANT: If this number is changed, the code needs adapting, I tried to add relevant comments to indicate where.
#define GROUP_SIZE_X 16
#define GROUP_SIZE_Y 8

#ifdef GEN_PASS
RWStructuredBuffer<uint> _HistogramBuffer;
#else
StructuredBuffer<uint> _HistogramBuffer;
#endif

// TODO_FCC: REMOVE THIS IS DEBUG.
RW_TEXTURE2D_X(float4, _TODO_REMOVE_ME);


// Because atomics are only on uint and we need a weighted value, we need to convert.
// If we multiply the weight by 2048, we get somewhat ok precision and we support up to
// the equivalent of 1920x1080 image in one bin. (Note, we run this at half res, so equivalent of 4k image)
uint PackWeight(float weight)
{
    return uint(weight * 2048);
}

float UnpackWeight(uint val)
{
    return val * rcp(2048.0f);
}

uint GetHistogramBinLocation(float value)
{
    float scaledLogLuma = ComputeEV100FromAvgLuminance(value) * _HistogramRangeScale + _HistogramRangeBias;
    return uint(saturate(scaledLogLuma) * (HISTOGRAM_BINS - 1));
}

float BinLocationToLogLuma(uint binIdx)
{
    return (binIdx * rcp(float(HISTOGRAM_BINS - 1))  - _HistogramRangeBias) / _HistogramRangeScale;
}

groupshared uint gs_localHistogram[HISTOGRAM_BINS];


// TODO_FCC: IMPORTANT TODO BEFORE PR:
//      If we keep this it is IMPERATIVE to have some guarantee on the coherency of the branch.

[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void KHistogramGen(uint groupIndex : SV_GroupIndex,
                   uint3 dispatchThreadId : SV_DispatchThreadID)
{
    // Groupshared memory is not guaranteed to be 0 initialized.
    // Note that currently the branch is always true (GROUP_SIZE_X * GROUP_SIZE_Y == HISTOGRAM_BINS). Here as safeguard if changing group size or bins.
    if (groupIndex < HISTOGRAM_BINS)    
    {
        gs_localHistogram[groupIndex] = 0u;
    }

    GroupMemoryBarrierWithGroupSync();

    // IMPORTANT TODO: This leads to poor cache behaviour, verify if we can use lower mip of the color pyramid.
    uint2 fullResCoords = dispatchThreadId.xy << 1u;

    if (all(fullResCoords < uint2(_ScreenSize.xy)))
    {
        float2 uv = ClampAndScaleUVForBilinear((fullResCoords + 0.5) * _ScreenSize.zw);
        float luminance = SampleLuminance(uv);
        float weight = WeightSample(fullResCoords, _ScreenSize.xy);

        uint  bin = GetHistogramBinLocation(luminance);

        _TODO_REMOVE_ME[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = float4((float)bin, weight, luminance, (log2(luminance) * _HistogramRangeScale + _HistogramRangeBias) * (HISTOGRAM_BINS - 1));

        InterlockedAdd(gs_localHistogram[bin], PackWeight(weight));
    }


    GroupMemoryBarrierWithGroupSync();

    if (groupIndex < HISTOGRAM_BINS)
    {
        InterlockedAdd(_HistogramBuffer[groupIndex], gs_localHistogram[groupIndex]);
    }
}

#define USE_WAVE_INTRINSICS     defined(PLATFORM_LANE_COUNT) && defined(PLATFORM_SUPPORTS_WAVE_INTRINSICS)


#if USE_WAVE_INTRINSICS

#define WAVE_SIZE   PLATFORM_LANE_COUNT
#define SUM_SCRATCH_SIZE  HISTOGRAM_BINS / WAVE_SIZE 

#else

#define SUM_SCRATCH_SIZE  HISTOGRAM_BINS 

#endif

groupshared float gs_partialSums[SUM_SCRATCH_SIZE];
groupshared float gs_values[HISTOGRAM_BINS];


[numthreads(HISTOGRAM_BINS, 1, 1)]
void KHistogramReduce(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    uint threadID = dispatchThreadId.x;
    float sum = 0;
    float histogramVal = UnpackWeight(_HistogramBuffer[threadID]);

#if USE_WAVE_INTRINSICS

    uint waveCount = (HISTOGRAM_BINS / WAVE_SIZE);
    float waveSum = WaveActiveSum(histogramVal);

    uint waveIDInGroup = threadID / WAVE_SIZE;
    if (WaveIsFirstLane())
    {
        gs_partialSums[waveIDInGroup] = waveSum;
    }

    gs_values[threadID] = histogramVal;

    // We have values for all the waves, let's sync. 
    GroupMemoryBarrierWithGroupSync();

    sum = gs_partialSums[0];
    for (uint i = 1u; i < waveCount; ++i)
    {
        sum += gs_partialSums[i];
    }

#else // !USE_WAVE_INTRINSICS

    gs_values[threadID] = histogramVal;
    gs_partialSums[threadID] = histogramVal;

    GroupMemoryBarrierWithGroupSync();

    // Sum all values
    for (uint i = HISTOGRAM_BINS >> 1u; i > 0u; i >>= 1u)
    {
        if (threadID < i)
            gs_partialSums[threadID] = (gs_partialSums[threadID] +  gs_partialSums[threadID + i]);

        GroupMemoryBarrierWithGroupSync();
    }

    sum = gs_partialSums[0];

#endif

    float2 extremesSums = float2(_HistogramMinPercentage, _HistogramMaxPercentage) * sum;

    // TODO: This can probably done more efficiently. Also verify that all but the first wave
    // actually skip this or if we need to enforce it somehow.
    if (threadID == 0)
    {
        float evProcessedSum = 0;
        float w = 0;
        // Delete
        float simpleSum = 0;
        float simpleLumaSum = 0;

        for (int i = 0; i < HISTOGRAM_BINS; ++i)
        {
            float histVal = gs_values[i];
            simpleSum += histVal;
            float binLogLuma = BinLocationToLogLuma(i);
            simpleLumaSum += histVal * binLogLuma;

            float off = min(extremesSums.x, histVal);
            extremesSums -= off;
            histVal -= off;

            histVal = min(extremesSums.y, histVal);
            extremesSums.y -= histVal;

            evProcessedSum += histVal * binLogLuma;
            w += histVal;

            _TODO_REMOVE_ME[uint3(i+1, 0, 0)] = float4(evProcessedSum, histVal, binLogLuma, simpleLumaSum / simpleSum);

        }

        w = max(w, 1e-4f);
        float avgEV = evProcessedSum * rcp(w);

        float exposure = AdaptExposure(avgEV - ParamExposureCompensation);
        exposure = clamp(exposure, ParamExposureLimitMin, ParamExposureLimitMax);
        _TODO_REMOVE_ME[uint3(0, 0, 0)] = float4(evProcessedSum, w, avgEV, exposure);
        _OutputTexture[uint2(0,0)] = float2(ConvertEV100ToExposure(exposure), exposure);

    }

    
}
