#pragma only_renderers d3d11 playstation xboxone vulkan metal switch

#pragma kernel CSMainEquirectangular                EQUIRECTANGULAR                     KerMain=CSMainEquirectangular
#pragma kernel CSMainFastOctahedral                 FAST_OCTAHEDRAL                     KerMain=CSMainFastOctahedral
#pragma kernel CSMainOctahedralConformalQuincuncial CONFORMAL_OCTAHEDRAL_QUINCUNCIAL    KerMain=CSMainOctahedralConformalQuincuncial

//#pragma multi_compile EQUIRECTANGULAR FAST_OCTAHEDRAL CONFORMAL_OCTAHEDRAL_QUINCUNCIAL

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Packing.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Sampling/Sampling.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"

TextureCube<float4> _Input;
RWTexture2D<float4> _Output;

SAMPLER(sampler_Input);

float4 _ScaleBias;

#if !defined(EQUIRECTANGULAR) && !defined(FAST_OCTAHEDRAL) && !defined(CONFORMAL_OCTAHEDRAL_QUINCUNCIAL)
    #error Projection not defined {EQUIRECTANGULAR, FAST_OCTAHEDRAL, CONFORMAL_OCTAHEDRAL_QUINCUNCIAL}
#endif

float3 SphericalTexCoordinateToDirection(float2 uvValue)
{
    float theta = ( 1.0f - uvValue.x )*TWO_PI;
    float phi   = ( uvValue.y - 0.5f )*PI;

    float csTh, siTh, csPh, siPh;
    sincos(theta, siTh, csTh);
    sincos(phi,   siPh, csPh);

    // theta is 0 at negative Z (backwards). Coordinate frame is (-Z,X) meaning negative Z is primary axis and X is secondary axis.
    return float3(siTh*csPh, siPh, -csTh*csPh);
}

float2 Corner(float u, float v)
{
    if (u*v >= 0.0f && u >= 0.0f)
        return float2( 1.0f - v,  1.0f - u);
    else if (u < 0.0f && v <= 0.0f)
        return float2(-1.0f - v, -1.0f - u);
    else if (u < 0.0f && v > 0.0f)
        return float2(-1.0f + v,  1.0f + u);
    else
        return float2( 1.0f + v, -1.0f + u);
}

float2 CornerBack(float u, float v)
{
    if (abs(u) + abs(v) >= 1.0f)
        return float2(u, v);
    else
        return Corner(u, v);
}

#define EllipticIntegralParam   (1.0f/2.0f)
#define EllipticK               (1.8540746773013717f)
#define EllipticPeriodicParam   (0.8472130847939793f) // pi/(2*EllipticK)
#define EllipticPeriodicParamD  (1.6944261695879586f) // pi/EllipticK
#define JacobiDNParam           (0.1465811135832811f) // Estimated on Mathematica

// EllipticF[x, 1/2]
float EllipticFHalfApprox(float x)
{
#if 0
    // Rough
    return 1.1808787030571934f*x;
#else
    // Better
    return 1.1802869761094772f*x - 0.10157022944264996f*sin(1.9983809090670122f*x);
#endif
}
float SNApprox(float x)
{
    return sin(EllipticPeriodicParam*x);
}
float CNApprox(float x)
{
    return cos(EllipticPeriodicParam*x);
}
float DNApprox(float x)
{
    return EllipticPeriodicParam + JacobiDNParam*cos(EllipticPeriodicParamD*x);
}

float2 CNNApprox(float2 Z)
{
    float zRe = Z.x;
    float zIm = Z.y;

    float reCN = CNApprox(zRe);
    float imCN = CNApprox(zIm);

    float reSN = SNApprox(zRe);
    float imSN = SNApprox(zIm);

    float reDN = DNApprox(zRe);
    float imDN = DNApprox(zIm);

    float t = 1.0f - reDN*reDN * imSN*imSN;

    return float2(
            reCN*imCN/t,
            (-reSN*reDN*imSN*imDN)/t
        );
}

float2 SquareToDiskConformalApprox(float2 XY)
{
    float zRe = XY.x*0.5f - XY.y*0.5f;
    float zIm = XY.x*0.5f + XY.y*0.5f;

    float2 r = CNNApprox(EllipticK*float2(1.0f - zRe, -zIm));

    return INV_SQRT2*float2(r.x + r.y, r.y - r.x);
}

real XXFastATan2(real x, real y)
{
    if (x > real(0.0))
        return /*FastATanPos*/FastATan(SafeDiv(y, sqrt(x * x + y * y) + x));
    //else if (x <= real(0.0) && abs(y) <= 1e-5f)
    else if (x < real(0.0) && abs(y) <= 1e-5f)
        return /*FastATanPos*/FastATan(SafeDiv(sqrt(x * x + y * y) - x, y));
    else
        return PI;
    // Theory: if x == 0 && y == 0 then NaN/UNDEFINED
}

float2 StereographicInverse(float x, float y)
{
    float r     = sqrt(max(x*x + y*y, 0.0f));
    float Phi   = //XXFastATan2(x, y);//
        atan2(y, x);
    float lat   = HALF_PI - 2.0f*atan(r);
    float lon   = Phi + HALF_PI;
    // (* if Center South
    //     lat=-lat;
    // *)
    return float2(lat, lon);
}

// Input [-1, 1]
float3 GetConformalQuincuncialDirection(float2 XY)
{
    /*
    float2 uuvv = CornerBack(XY.x, XY.y);
    float2 S    = float2(uuvv.x - uuvv.y, uuvv.x + uuvv.y);

    float2 C    = SquareToDiskConformalApprox(S);
    float2 sph  = BreusingHarmonicMeanInverse(C.x, C.y);

    if (abs(XY.x) + abs(XY.y) > 0.0f)
        sph.x += HALF_PI;
    else
        sph.x -= HALF_PI;
    */
    bool isCenter = (abs(XY.x) + abs(XY.y) <= 1.0f);
    float2 v;
    if (!isCenter)
    {
        if (XY.x*XY.y >= 0.0f)
        {
            // I or III
            if (XY.x >= 0.0f)
                v = float2(-XY.y + 1.0f, -XY.x + 1.0);
            else
                v = float2(-XY.y - 1.0f, -XY.x - 1.0);
        }
        else
        {
            // II or IV
            if (XY.x < 0.0f)
                v = float2(XY.y - 1.0f, XY.x + 1.0);
            else
                v = float2(XY.y + 1.0f, XY.x - 1.0);
        }
    }
    else
    {
        v = XY;
    }
    float2 S   = float2(v.x - v.y, v.x + v.y);
    float2 xy  = SquareToDiskConformalApprox(S);
    float2 sph = StereographicInverse(xy.x, xy.y);

    if (!isCenter)
        sph.x *= -1.0f;
    sph.y -= PI_DIV_FOUR;
    if (sph.y < -PI)
        sph.y += TWO_PI;
    //if (!isCenter)
    //    sph.y *= -1.0f;
    //sph.x -= PI_DIV_FOUR;
    //if (sph.x < -PI)
    //    sph.x += TWO_PI;

    //sph.y += PI_DIV_FOUR;

    //sph.x += 4.0f*HALF_PI;
    //sph.y += 5.0*PI_DIV_FOUR;

    float csTh, siTh, csPh, siPh;
    sincos(sph.x, siTh, csTh);
    sincos(sph.y, siPh, csPh);

    //.xzy
    return float3(siTh*csPh, siPh, -csTh*csPh);
    //return float3(csTh*csPh, siTh*csPh, siPh);
    //{Cos[\[Phi]] Sin[\[Theta]], Sin[\[Theta]] Sin[\[Phi]], Cos[\[Theta]]}
    //return float3(csPh*siTh, siTh*siPh, csTh);
}

[numthreads(8, 8, 1)]
void KerMain(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    uint2  pixCoord = dispatchThreadId.xy;
    float2 uv       = float2(pixCoord.xy)*_ScaleBias.xx + _ScaleBias.zz;

    float4 output;

    float3 dir;
#if     defined(EQUIRECTANGULAR)
    dir = SphericalTexCoordinateToDirection(uv);
#elif   defined(FAST_OCTAHEDRAL)
    dir = UnpackNormalOctQuadEncode(2.0f*uv - 1.0f);
#else //defined(CONFORMAL_OCTAHEDRAL_QUINCUNCIAL)
    dir = GetConformalQuincuncialDirection(2.0f*uv - 1.0f);
#endif

    output.rgb = SAMPLE_TEXTURECUBE_LOD(_Input, sampler_Input, dir, 0).rgb;
    output.w   = 1.0f;

    _Output[pixCoord] = output;
}
